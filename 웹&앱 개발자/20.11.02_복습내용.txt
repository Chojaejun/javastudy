=: 대입연산자
a = b; // b를 a에 대입하라.
a = 4; // 4를 a에 대입하라.

지역(local)변수 : 유지보수 편하게 함.
메서드 안에서 중복되는 데이터는 변수 처리.
클래스 안에서 중복되는 코드는 메서드 처리.
프로젝트 안에서 중복되는 메서드&변수&상수는 상속 처리.
변수 선언 공식
자료형 변수명 = 자료형에 맞는 값;

자료형:
1. 기본자료형:
boolean, char, byte, short, int, long, float, double 
2. 참조자료형: 기본자료형이 아닌 자료형. 
참조자료형 변수명 = new 생성자( );
new: 힙메모리에 저장공간을 할당하라는 의미
변수명: 객체가 저장된 힙메모리의 주소값.
Dog d1 = new Dog( );
Dog d2 = new Dog( );
Dog d3 = d1;
여기서 객체는 new가 붙은 d1,d2

지역변수 Vs 멤버변수
1. 지역변수: 메서드나 생성자 안에서 선언된 변수. 
스코프: 선언된 순간부터 ~ 가장 가까운 } 까지.
자료형 변수명; -> 변수 선언.
자료형 변수명 = 자료형에 맞는 값; -> 선언과 초기화.
변수명 = 자료형에 맞는 값; -> 대입..대입을 위해서는 반드시 선언이 있어야 함.
멤버변수명 = 자료형에 맞는 값; -> 만약에 생성자에 이런 코드가 있다면 -> 초기화.

2. 멤버변수: 클래스의 필드에서 선언해야 한다.
스코프 : 해당클래스 전체..private;
private 자료형 변수명;
초기화는 생성자 안에서 이루어짐.
객체의 구성 요소 역할을 하고 
클래스의 구성요소

메서드: 객체의 기능(=능력=행위)
public 반환형 메서드명(자료형1 변수명1, 자료형2 변수명2) {

               //return 자료형에 맞는 값; 반환형이 void가 아닐 때..
}

- 무반환 무파람: 메서드명( );
- 무반환 유파람: set( ) , 메서드명(자료형에 맞는 값1, 자료형에 맞는 값2..);
- 유반환 무파람: get( ), 반환형과 같은 자료형 변수명 = 메서드명( );
- 유반환 유파람: 반환형과 같은 자료형 변수명 = 메서드명(자료형에 맞는 값1, 자료형에 맞는 값2...);


메서드 오버로딩(=오버로딩): 같은 클래스, 메서드 이름 같음.
파라미터의 자료형과 관련되어 있음.
접근제한자 의미없음.
반환형 아무 영향 못미침.
파라미터의 변수형 의미없음.
1. 메서드의 파라미터의 개수가 다르면 오버로딩 성립.
2. 메서드의 파라미터의 자료형이 다르면 오버로딩 성립.
3. 메서드의 파라미터의 배치 순서가 다르면 오버로딩 성립.


생성자: 객체 생성 시 값을 제공, 멤버변수 초기화
- 디폴트 생성자: 파라미터가 없으면 디폴트 생성자
- 사용자 생성자: 파라미터가 있으면 사용자 생성자

생성자가 눈에 안 보인다: 생성자 몇 개 있나? 1개.. 디폴트 생성자가 안보이는 상태로 존재함.
사용자 생성자가 2개가 눈에 보인다: 생성자 몇 개? 2개.. 디폴트 생성자는 없다.
이 상태로 디폴트 생성자를 생성하려면 직접 입력해서 생성해야 함.

동적인 객체를 만들고 싶다면..? 사용자 생성자
public 클래스명( ) {

}

this: 객체 자기 자신.. 지역변수와 멤버변수의 변수명이 같을 때, 
컴파일러가 지역변수를 우선적으로 인식
a = a; (지역변수로 인식)
this.a = a;(멤버변수로 인식)
this( ): 해당 클래스의 생성자 호출..
this(3);
this(new Dog( ));

생성자의 첫 라인에 작성해야 함.( <- 이러한 걸림돌 때문에 메서드를 사용함)



클래스와 객체
1. 객체: 국어 사전에서 명사...힙메모리에 저장된 데이터...실체
- 참조자료형 객체명 = new 생성자( );
- 힙메모리에 저장된다.
- 참조자료형으로 만들어짐.
객체가 갖고 있는 자원에 접근 또는 사용할 때
객체명.변수명;
객체명.상수명;
객체명.메서드명;

2. 클래스: 설계도의 의미.. class라는 키워드가 있어야 클래스..
클래스는 단독으로 실행되지 않는다... 
반드시 객체를 만들어서 실행해야 한다.
클래스의 구성요소: 멤버변수/상수, 생성자, 메서드

객체의 구성 요소를 표현하는 자료: 멤버변수/상수
객체의 생성법을 표현하는 자료: 생성자
객체의 기능을 표현하는 자료: 메서드

참조자료형의 변수(=객체=인스턴스) 갖고 있는 자원에 접근하려면 어떻게?
객체명.



if문(상황에 따라 실행코드를 달리하고 싶을 때 사용, ~면, ~라면, ~이면)
- 단순 if : ~면 ~해라
- if ~ else : ~면 ~해라, 그렇지 않으면 ~해라.
- 다중 if : ~면 ~해라, 그렇지 않고 ~면 ~해라, 그렇지 않고 ~면 ~해라, 그렇지 않으면 ~해라.

if(a>3) {

 }else if(a>1) {

 }else {

 }



switch ~ case : ==, int, String, enum
break

switch(변수/10) {
             case1:
                       sysout(1);
                       break;
             case2:
                       sysout(2);
                       break;
             default:
                       sysout(3);
                       break;
 }



반복문
- 특정 코드들을 반복하는 기능.
- for, while, do ~ while
1.for문
-for( ) 적습니다.
-( )소괄호 안에 초기화, 조건식, 증감식을 적습니다.
-( )소괄호 옆에 중괄호{  } 를 적습니다.
-


for(int i = 0; i < 20; i++ ) {

          sysout("hello world");

}



return의 기능
1. 값 반환의 의미
2. 메서드 실행 중단..return;

break: 가장 가까운 반복문을 빠져나감.
continue: 해당 회차를 빠져나감.


연산자
대입연산자: =
산술연산자: +, -, *, /, %
switch 알고리즘
int a = 1;
a = 1 - a;
/: 정수형에서는 몫
0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, -> n/3
%: 나머지 연산자,  어떤 수가 배수인지 여부...
n % 3 == 0
0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3,......
n % 4

a += b // a = a + b;
a -= b // a = a - b;
a *= b // a = a * b;
a /= b // a = a / b;
a %= b // a = a %b;

>, >=, <, <=, ==, != : boolean

&&, ||, !
&&: 연산에 참여하는 데이터가 모두 true일 때만 true, 그렇지 않으면 false
|| : 연산에 참여하는 데이터가 모두 false 일 때만 false, 그렇지 않으면 true
! : 값 반전.. true -> false, false -> true

++, -- : 1씩 증감..
++a, --a : 즉시 증가해서 a에 대입.
a++, a-- : 나중에 a를 만났을 때 대입.

int a = 10;
sysout(a++);

int a = 10;
sysout(++a);

int a = 10;
a = ++a;

int a = 10;
a = a++;

&, |, ^, ~

>>, <<

84 >> 2 : 84/2^n
84 << 4 : 84 * 2^4

조건연산자(=삼항연산자)

type 변수명 = 조건식? 참일 때의 값 : 거짓일 때의 값;
type 변수명 = 조건식1? 참일 때의 값1 : 조건식2? 참일 때의 값2 : 조건 1,2가 모두 거짓일 때의 값;  



while문
1. 변수 선언 및 초기화
2. while(조건식)라 적고
3. boolean형의 결과가 나오는 조건식을 적는다.
4. ( ) 소괄호 
 























